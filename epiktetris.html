<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Epiktetris</title><!-- Mon Jan 19 23:25 2026 -->
  <style>
    :root {
      --bg-color: #fff8f0; --text:   #000000;
      --ui-bg:    #fff0d5; --accent: #e67e22;
    }
    body {
      font-family: Arial, Helvetica, Verdana, sans-serif;
      background-color: var(--bg-color);
      color:            var(--text);
      display: flex;
      flex-direction:  column;
      align-items:     center;  height: 100vh;  overflow:   hidden;
      justify-content: center;  margin:     0;  user-select:  none;
    }
    canvas {
      display: block;
      background-color: #d0d0d0;
      border:    2px solid #555;
    }
    #game-container {
      display: flex; flex-direction: column; position: relative;
      gap:     12px; background:    #e0e0e0;
      padding: 12px; border: 4px solid #444;
      box-shadow: 0 0 20px rgba(0,0,0, 0.8);
    }
    #game-panel {
      position: relative;
      width: fit-content;
    }
    #ui-panel {
      display: flex;           gap:    15px;
      flex-direction: column;  width: 100px;
    }
    .panel-box {
      background: var(--ui-bg);  padding:      10px;
      border:   2px solid #555;  text-align: center;
    }
    h2 {
      font-size: 0.9rem;  color:          #888;
      margin: 0 0 5px 0;  letter-spacing:  1px;
    }
    .value {
       font-size: 1.5rem;
       font-weight: bold; color: var(--accent);
    }
    .icon-large {
      font-size: 1.5rem;
      font-weight: bold;
    }
    .key-hint {
      font-size: 0.7rem;
      color:       #aaa;  border: 1px solid #aaa;
      margin-top:   5px;  border-radius:     4px;
      padding:  2px 6px;  display:  inline-block;
    }
    #overlay {
      top: 0; left: 0; width: 100%; height: 100%;
      position: absolute;
      background: rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      justify-content:   top;   z-index:   10;
      align-items:    center;   display: none;
    }
    #overlay h1 {
      font-size: 2rem;  text-transform: uppercase;
      margin: 0;        color:      var(--accent);
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
    }
    #overlay p {
      font-size: 0.8rem;           color: #e0e0e0;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
    }
    #panel-row {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 12px;
      min-width: 180px;
    }
    .control-btn {
      flex: 1 1 auto;
      font-size: 1.1rem;
      font-weight: bold;
      color: #222;
      background: #f7e4c6;
      border: 2px solid #666;
      border-radius: 10px;
      box-shadow: 0 2px 0 rgba(0,0,0,0.2);
      height: 48px;
      min-width: 60px;
      touch-action: none;
    }
    .control-btn:active,
    .control-btn.active {
      transform: translateY(1px);
      box-shadow: 0 1px 0 rgba(0,0,0,0.25);
      background: #f0d3a2;
    }
    .controls-hint {
      font-size: 0.8rem;  color:     #a0a0a0;
      margin-top:  10px;  text-align: center;
    }
    .game-hint {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.8rem;
      color:    #808080;  text-align: center;
    }
  </style>
</head>
<body>
  <div id="game-container" tabindex="-1">
    <div id="panel-row">
      <div id="game-panel">
        <canvas id="tetris" width="240" height="500"></canvas>
        <div id="overlay">
          <h1 id="overlay-title">PAUSED</h1>
          <p id="overlay-msg">...</p>
        </div>
      </div>
      <div id="ui-panel">
        <button class="control-btn" data-action="pause">
                <div class="icon-large">⏸</div></button>
        <div class="game-hint" id="next-type">X</div>
        <div class="panel-box">
          <h2>Next</h2>
          <canvas id="next" width="72" height="72"></canvas>
        </div>
        <button class="control-btn" data-action="swap">Swap</button>
        <button class="control-btn" data-action="mirror" id="mirror-btn">
                 <div class="icon-large">⇄</div></button>
        <button class="control-btn" data-action="rotate-left">
                      <div class="icon-large">↺</div></button>
        <div class="panel-box">
          <h2>Score</h2>
          <div id="score" class="value">0</div>
        </div>
      </div>
    </div>
    <div id="panel-row">
      <button class="control-btn" data-action="left">◀</button>
      <button class="control-btn" data-action="right">▶</button>
      <button class="control-btn" data-action="down">▼</button>
      <button class="control-btn" data-action="drop">Drop</button>
    </div>
  </div>
  <div class="controls-hint">
    WASD/arrows: move/rotate | Q/del: swap | Z/end: mirror | space: drop | F1/esc: pause
  </div>
  <script>

const canvas      = document.getElementById('tetris');
const nextCanvas  = document.getElementById('next');
const context     =     canvas.getContext('2d');
const nextContext = nextCanvas.getContext('2d');
const COLS = 12;          context.scale(20, 20);
const ROWS = 25;      nextContext.scale(12, 12);
let score   = 0;
let lastTime = 0;        let speedUp    = false;
let canMirror = true;    let drawGhost  = false; let tempGhost  = false;
let dropCounter =  0;    let ghostCounter =   0; let isPaused   = false;
let dropInterval = 1200; let ghostTimeout = 500; let isGameOver = false;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const Pieces = 'hijklmnopqrstuvwxyz123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const Colors = {};
const Shapes = {
  'h': [[-1,-1], [-1,0], [0,0], [ 0,1]],
  'i': [[ 0,-1], [0, 0], [0,1], [ 0,2]],
  'j': [[ 0,-1], [0, 0], [0,1], [-1,1]],
  'k': [[ 0,-1], [0, 0], [0,1], [ 1,0]],
  'l': [[ 0,-1], [0, 0], [0,1], [ 1,1]],
  'm': [[-1, 0], [0, 0],[-1,1], [ 0,1]],
  'n': [[ 0, 0], [0, 1], [1,0], [1,-1]],

  'o': [[ 0,-2], [ 0,-1], [0, 0], [0,1], [ 0, 2]],
  'p': [[ 0,-1], [ 0, 0], [0, 1], [1,0], [ 1,-1]],
  'q': [[ 0,-1], [ 0, 0], [0, 1], [0,2], [ 1, 2]],
  'r': [[ 0,-1], [ 1,-1], [0, 0],[-1,0], [ 0, 1]],
  's': [[-1,-1], [-1, 0], [0, 0], [0,1], [ 0, 2]],
  't': [[-1,-1], [ 0,-1], [1,-1], [0,0], [ 0, 1]],
  'u': [[-1, 0], [-1, 1], [0, 1], [1,1], [ 1, 0]],
  'v': [[-1,-1], [-1, 0], [-1,1], [0,1], [ 1, 1]],
  'w': [[-1,-1], [-1, 0], [0, 0], [0,1], [ 1, 1]],
  'x': [[ 0,-1], [-1, 0], [0, 0], [1,0], [ 0, 1]],
  'y': [[ 0,-1], [ 0, 0], [0, 1], [0,2], [-1, 0]],
  'z': [[-1,-1], [ 0,-1], [0, 0], [0,1], [ 1, 1]],

  '1': [[ 0,-2], [ 0,-1], [ 0, 0], [0, 1], [ 0, 2], [-1,-1]],
  '2': [[-1,-1], [ 0,-1], [ 0, 0], [0, 1], [ 1,-1], [ 1, 0]],
  '3': [[-1,-1], [ 0,-1], [ 0, 0], [0, 1], [ 1, 1], [ 1, 2]],
  '4': [[-1,-1], [-1, 0], [ 0, 0], [1,-1], [ 1, 0], [ 1, 1]],
  '5': [[ 0,-1], [ 0, 0], [ 0, 1], [0, 2], [-1, 1], [ 1, 0]],
  '6': [[-1, 0], [-1, 1], [-1, 2], [0,-1], [ 0, 0], [ 1, 0]],
  '7': [[-2, 0], [-1, 0], [ 0, 0], [1, 0], [ 0, 1], [ 0, 2]],
  '8': [[-1, 0], [-1, 1], [ 0,-1], [0, 0], [ 0, 1], [ 1, 0]],
  '9': [[-1, 0], [ 0, 0], [ 0, 1], [0, 2], [ 1,-1], [ 1, 0]],
  'A': [[ 0,-1], [ 0, 0], [ 0, 1], [0, 2], [-1, 1], [ 1,-1]],
  'B': [[ 0, 0], [ 0, 1], [ 0, 2], [1,-1], [ 1, 0], [ 1, 1]],
  'C': [[ 0,-1], [ 0, 0], [ 0, 1], [0, 2], [ 1,-1], [ 1, 2]],
  'D': [[ 0,-1], [ 0, 0], [ 0, 1], [0, 2], [ 1, 0], [ 1, 1]],
  'E': [[ 0,-2], [ 0,-1], [ 0, 0], [0, 1], [ 0, 2], [ 1, 0]],
  'F': [[ 0,-1], [ 0, 0], [ 0, 1], [0, 2], [ 1,-1], [ 1, 1]],
  'G': [[-1,-1], [-1, 0], [-1, 1], [0,-1], [ 0, 1], [ 0, 2]],
  'H': [[ 0,-2], [ 0,-1], [ 0, 0], [1,-0], [ 1, 1], [ 1, 2]],
  'I': [[ 0,-2], [ 0,-1], [ 0, 0], [0, 1], [ 0, 2], [ 0, 3]],
  'J': [[ 0,-2], [ 0,-1], [ 0, 0], [0, 1], [ 0, 2], [ 1,-2]],
  'K': [[-1, 1], [-1, 2], [ 0,-1], [0, 0], [ 0, 1], [ 1, 0]],
  'L': [[-1,-2], [-1,-1], [-1, 0],[-1, 1], [ 0, 1], [ 1, 1]],
  'M': [[-1, 0], [-1, 1], [-1, 2], [0,-1], [ 0, 0], [ 1,-1]],
  'N': [[-1, 0], [-1, 1], [-1, 2], [0, 0], [ 1,-1], [ 1, 0]],
  'O': [[-1,-1], [-1, 0], [-1, 1], [0,-1], [ 0, 0], [ 0, 1]],
  'P': [[ 0,-1], [ 0, 0], [ 0, 1], [0, 2], [ 1,-1], [ 1, 0]],
  'Q': [[-1,-1], [-1, 0], [ 0,-1], [0, 0], [ 0, 1], [ 1, 1]],
  'R': [[ 0,-1], [ 0, 0], [ 0, 1], [0, 2], [-1, 0], [ 1,-1]],
  'S': [[ 0,-1], [ 0, 0], [ 0, 1], [0, 2], [-1,-2], [-1,-1]],
  'T': [[-1,-1], [ 0,-1], [ 0, 0], [0, 1], [ 0, 2], [ 1,-1]],
  'U': [[-1,-1], [-1, 0], [-1, 1], [0,-1], [ 1,-1], [ 1, 0]],
  'V': [[-1,-1], [-1, 0], [-1, 1], [0, 0], [ 0, 1], [ 1, 1]],
  'W': [[-2, 1], [-1, 0], [-1, 1], [0,-1], [ 0, 0], [ 1,-1]],
  'X': [[-1, 0], [ 0,-1], [ 0, 0], [0, 1], [ 0, 2], [ 1, 0]],
  'Y': [[-1,-1], [-1, 0], [ 0, 0], [0, 1], [ 1,-1], [ 1, 0]],
  'Z': [[-1,-1], [ 0,-1], [ 0, 0], [0, 1], [ 0, 2], [ 1, 2]],
};
let nextPieceType   = null;
let nextPieceMatrix = null;
let bagContent = '';
let Bag = '';
let bagCount = 0;

function initBricks()
{
  let deltaHue = 20
  let hue = 0;
  for (const x of Pieces) {
    if (x === '1') { hue = -90; deltaHue = 11; }
         if (Shapes[x].length === 6) Colors[x] = { 'H':hue, 'S':70, 'L':70 };
    else if (Shapes[x].length === 5) Colors[x] = { 'H':hue, 'S':80, 'L':50 };
    else                             Colors[x] = { 'H':hue, 'S':90, 'L':40 };
    hue += deltaHue;
  }
  const params = window.location;
  const sp = new URLSearchParams(params.search);
  if (sp.has('bag')) bagContent = sp.get('bag');
  if (sp.has('set')) {
    for (const x of sp.get('set')) {
           if (x === '4') bagContent += 'hijklmn';
      else if (x === '5') bagContent += 'opqrstuvwxyz';
      else if (x === '6') bagContent += '123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  } }
  if (bagContent.length === 0) {
      bagContent = '123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'+'hijklmnopqrstuvwxyz'
                                                        +'hijklmnopqrstuvwxyz';
  }
  speedUp = sp.has('su');
  console.log(`bag=${bagContent};su=${speedUp}`);
}
function nextPieceFromBag()
{
  if (Bag.length === 0) {
    const shuffle = str => [...str].sort(() => Math.random()-0.5).join('');
    Bag = shuffle(bagContent);     if (bagCount < 99) bagCount++;
    if (speedUp) dropInterval = Math.max(250,1250-(50*bagCount));
  }
  const nextPiece = Bag[0];
  Bag =       Bag.slice(1); return nextPiece;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function createMatrix(w, h)
{
  const         matrix =                       [];
  while (h--) { matrix.push(new Array(w).fill(0)); }
  return matrix;
}
const arena = createMatrix(COLS, ROWS);
const brick = {
  pos: {x: 0, y: 0},
  type:   null,
  matrix: null,
};
function createPiece(type)
{
  const coords =       Shapes[type];
  const matrix = createMatrix(6, 6);
  coords.forEach(c => { matrix[c[1]+2][c[0]+2] = type; });
  return matrix;
}
function drawMatrix(matrix, offset, bt, ctx = context)
{                                   //
  matrix.forEach((row, y) => {      // brick type
    row.forEach((value, x) => {     //   0:regular
      if (value !== 0) {            //   1:arena
        let H = Colors[value].H;    //   2:ghost
        let S = Colors[value].S;    //   3:next
        let L = Colors[value].L;
        if (bt == 2) {
          ctx.fillStyle = `hsl(${H},100%,50%,0.125)`;
          ctx.fillRect(x+offset.x, y+offset.y, 1, 1);
        }
        else {
          if (bt == 1) { S *= 0.4; L *= 1.2; }
          ctx.fillStyle = `hsl(${H},${S}%,${L}%)`;
          ctx.fillRect(x+offset.x, y+offset.y, 1, 1);

          ctx.lineWidth = 0.05;
          ctx.strokeStyle = `hsl(${H},${S}%,20%)`;
          ctx.strokeRect(x+offset.x, y+offset.y, 1, 1);

          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          ctx.fillRect(x+offset.x, y+offset.y,     1, 0.1);
          ctx.fillRect(x+offset.x, y+offset.y+0.1, 0.1, 1);
      } }
      else if (bt & 1) {
        ctx.lineWidth = (bt == 1) ? 0.02 : 0.01;
        ctx.strokeStyle = 'rgba(220,200,180,1)';
        ctx.strokeRect(x+offset.x+0.1, y+offset.y+0.1, 0.8, 0.8);
      }
    });
  });
}
function draw()
{
  context.fillStyle = '#ffffff';
  context.fillRect(0, 0, canvas.width, canvas.height);
  drawMatrix(arena,     {x: 0, y: 0}, 1);
  drawMatrix(brick.matrix, brick.pos, 0);
  if (drawGhost || tempGhost) {
    let ghost = { pos: { x: brick.pos.x,     y: brick.pos.y },
                      type: brick.type, matrix: brick.matrix,
    };
    while(!collide(arena, ghost)) ghost.pos.y++;
                                  ghost.pos.y--;
    drawMatrix(ghost.matrix,
               ghost.pos,2);
} }
function drawNext()
{
  nextContext.fillStyle = '#ffffff';
  nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
  drawMatrix(nextPieceMatrix, {x: 0, y: 0}, 3, nextContext);
  let hints = `${bagCount}:${brick.type}(${nextPieceType})${Bag}`;
  if (hints.length > 10) hints = hints.slice(0, 9) + "…";
  document.getElementById('next-type').innerText = hints;
}
function collide(arena, brick)
{
  const m = brick.matrix;
  const o = brick.pos;
  for (let y = 0; y < m.length; ++y) {
    for (let x = 0; x < m[y].length; ++x) {
      if (m[y][x]                                !== 0
        && (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0) { return true; }
    }
  }
  return false;
}
function merge(arena, brick)
{
  brick.matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) { arena[y + brick.pos.y][x + brick.pos.x] = value; }
    });
  });
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function doesntFit()
{
  let offset = 1;
  while (collide(arena, brick)) {
    brick.pos.x += offset;
    offset = -(offset + (offset > 0 ? 1 : -1));
    if (offset > 5) { return true; }
  }
  return false;
}
function rotate(matrix, dir)
{
  for (let y = 0; y < matrix.length; ++y) {
    for (let x = 0; x < y; ++x) {
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if (dir > 0) matrix.forEach(row => row.reverse());
  else         matrix.reverse();
}
function brickRotate(dir)
{
  const pos  =  brick.pos.x;
  rotate(brick.matrix, dir);
  if (doesntFit()) { rotate(brick.matrix, -dir);
                     brick.pos.x = pos;        }
}
function mirror(matrix)
{
  matrix.forEach(row => row.reverse());
}
function brickMirror()
{
  if (!canMirror)  return;
  const pos = brick.pos.x;
  mirror(brick.matrix);
  if (doesntFit()) { mirror(brick.matrix);
                     brick.pos.x = pos;  }
}
function updateCanMirror()
{
  canMirror =          (Shapes[brick.type].length > 4);
  const button = document.getElementById('mirror-btn');
  button.style.opacity =    canMirror ? '1.0' : '0.25';
}
function brickSwap()
{
  const currentMatrix = brick.matrix;
  const currentType   = brick.type;
  brick.type   = nextPieceType;
  brick.matrix = nextPieceMatrix;
  if (doesntFit()) {
    brick.type   = currentType;
    brick.matrix = currentMatrix;
  }
  else { nextPieceType   = currentType;
         nextPieceMatrix = currentMatrix;
         drawNext();
         updateCanMirror();             }
}
function brickDrop()
{
  if (isPaused || isGameOver) return;  brick.pos.y++;
  if (collide(arena, brick)) {         brick.pos.y--;
    merge(arena, brick);
    brickReset();
  }
  dropCounter = 0;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function brickReset()
{
  if (nextPieceType === null) { nextPieceType   =         nextPieceFromBag();
                                nextPieceMatrix = createPiece(nextPieceType); }
  brick.type = nextPieceType;
  brick.matrix = nextPieceMatrix;
  nextPieceType   =         nextPieceFromBag();
  nextPieceMatrix = createPiece(nextPieceType);
  updateCanMirror();
  drawNext();
  brick.pos.y = 0;
  brick.pos.x = (arena[0].length / 2 | 0) - (brick.matrix[0].length / 2 | 0);

  if (collide(arena, brick)) {
    isGameOver = true;
    const overlay = document.getElementById('overlay');
    document.getElementById('overlay-title').innerText = "GAME OVER";
    document.getElementById('overlay-msg').innerText = "Reload page to restart";
    overlay.style.display = 'flex';
    overlay.style.background = 'rgba(0,0,0, 0.5)';  return;
  }
  let rowCount = 0; // collapse filled rows
outer:
  for (let y = arena.length-1; y > 0; --y) {
    for (let x = 0; x < arena[y].length; ++x) {
      if (arena[y][x] === 0) continue outer;
    }
    const row = arena.splice(y, 1)[0].fill(0);
    arena.unshift(row);    ++y;    rowCount++;
  }
  if (rowCount > 0)                score += rowCount;
  document.getElementById('score').innerText = score;
}
function togglePause()
{
  if (isGameOver) return;      isPaused = ! isPaused;
  const overlay = document.getElementById('overlay');
  if (isPaused) {
    document.getElementById('overlay-title').innerText = "PAUSED";
    document.getElementById('overlay-msg').innerText = "";
    overlay.style.display = 'flex';
    overlay.style.background = 'rgba(0,0,0, 0.0)'; // transparent
  }
  else { overlay.style.display = 'none'; update(); }
}
function update(time = 0)
{
  if (isPaused) return;               const deltaTime = time - lastTime;
                                                        lastTime = time;
  dropCounter += deltaTime; if (dropCounter > dropInterval) brickDrop();
  if (tempGhost) {
        ghostCounter +=   deltaTime;
    if (ghostCounter > ghostTimeout) tempGhost = false;
  }
  draw();
  requestAnimationFrame(update);
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function canAct()
{
  if (isGameOver)              return false;
  if (isPaused) togglePause(); return  true;
}
function moveLeft()
{
  if (canAct()) {              brick.pos.x--;
    if (collide(arena, brick)) brick.pos.x++;
} }
function moveRight()
{
  if (canAct()) {              brick.pos.x++;
    if (collide(arena, brick)) brick.pos.x--;
} }
function softDrop()
{
  if (canAct()) {
    tempGhost = true;
    ghostCounter = 0; brickDrop();
} }
function hardDrop()
{
  if (canAct()) {
    while(!collide(arena, brick)) brick.pos.y++;
                                  brick.pos.y--;
    merge(arena, brick);
    dropCounter =     0; brickReset();
} }
function rotateLeft()  { if (canAct()) brickRotate(-1); }
function doSwap()      { if (canAct()) brickSwap();     }
function doMirror()    { if (canAct()) brickMirror();   }
const actionHandlers = {
  left:          moveLeft,
  right:         moveRight,
  down:          softDrop,
  drop:          hardDrop,
  'rotate-left': rotateLeft,
  swap:          doSwap,
  mirror:        doMirror,
  pause:         togglePause,
};
const repeatableActions = new Set(['left', 'right', 'down']);
let repeatButton   = null;
let repeatTimer    = null;
let repeatInterval = null;
function clearRepeat()
{
  if (repeatButton) repeatButton.classList.remove('active');
                                                     repeatButton   = null;
  if (repeatTimer)    clearTimeout (repeatTimer);    repeatTimer    = null;
  if (repeatInterval) clearInterval(repeatInterval); repeatInterval = null;
}
function startRepeat(action, button)
{
  clearRepeat();
  const handler = actionHandlers[action];
  if (handler) { handler();
    repeatButton =  button;
    repeatButton.classList.add('active');
    repeatTimer = setTimeout(() =>
        { repeatInterval = setInterval(handler,80); }, 200);
} }
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const mobileControls = document.getElementById('game-container');
if (mobileControls) {
  mobileControls.addEventListener('pointerdown', event => {
    const button = event.target.closest('button[data-action]');
    if (!button) return;
    const action = button.dataset.action;
    event.preventDefault();
    if (repeatableActions.has(action)) {
      startRepeat(action, button);
    }
    else {
      const handler = actionHandlers[action];
      if (handler) handler();
      button.classList.add('active');
      setTimeout(() => button.classList.remove('active'), 120);
    }
  });
  const stopRepeat = event => {
    event.preventDefault();
    clearRepeat();
  };
  mobileControls.addEventListener('pointerup', stopRepeat);
  mobileControls.addEventListener('pointercancel', stopRepeat);
  mobileControls.addEventListener('pointerleave', stopRepeat);
}
const swipeThreshold = 30;
let touchStartX = null;
let touchStartY = null;
canvas.addEventListener('touchstart', event => {
  if (event.touches.length !== 1) return;
  const t = event.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
  event.preventDefault();
}, { passive: false });
canvas.addEventListener('touchmove', event => {
  if (touchStartX === null || touchStartY === null) return;
  event.preventDefault();
}, { passive: false });
canvas.addEventListener('touchend', event => {
  if (touchStartX === null || touchStartY === null) return;
  const t = event.changedTouches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;
  touchStartX = null;
  touchStartY = null;
  const absX = Math.abs(dx);
  const absY = Math.abs(dy);
  if (absX < swipeThreshold && absY < swipeThreshold) return;
  if (absX > absY) {
    if (dx > 0) moveRight();
    else        moveLeft();
  }
  else {
    if (dy > 0) softDrop();
    else        rotateRight();
  }
  event.preventDefault();
}, { passive: false });
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
document.addEventListener('keydown', event =>
{
  const allSupportedKeycodes = [32,37,38,39,40,35,    8,
                                   65,87,68,83,90,220,81,46];
  if (isGameOver) return;
  if (event.keyCode === 88) { // X
    drawGhost = !drawGhost;
    draw();         return;
  }
  else if (event.keyCode === 27 || event.keyCode === 112) { // ESC or F1
    togglePause();
    event.preventDefault(); return;
  }
  else if (isPaused && allSupportedKeycodes.includes(event.keyCode))
    togglePause();     // no return
// - - - - - - - - - - - - - - - - - -
  if  (event.keyCode === 37    // Left
    || event.keyCode === 65) { // A
    brick.pos.x--;
    if (collide(arena, brick)) brick.pos.x++;
  }
  else if (event.keyCode === 39    // Right
        || event.keyCode === 68) { // D
    brick.pos.x++;
    if (collide(arena, brick)) brick.pos.x--;
  }
  else if (event.keyCode === 38    // Up
        || event.keyCode === 87) { // W
    brickRotate(-1);
    event.preventDefault();
  }
  else if (event.keyCode === 40    // Down
        || event.keyCode === 83) { // S
    softDrop();
    event.preventDefault();
  }
  else if (event.keyCode === 35     // End
        || event.keyCode === 90     // Z
        || event.keyCode === 220) { // \ (mirror)
    brickMirror();
    event.preventDefault();
  }
  else if (event.keyCode === 8     // backspace
        || event.keyCode === 81    // Q
        || event.keyCode === 46) { // Del (swap)
    brickSwap();
    event.preventDefault();
  }
  else if (event.keyCode === 32) { hardDrop(); } // Space
});
// document.addEventListener('keyup', event =>
// {
//   if (event.keyCode === 17) { drawGhost = false; draw(); }
// });
initBricks();
brickReset(); update();

  </script>
</body>
</html>
